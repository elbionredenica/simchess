<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SimChess - Simultaneous Chess</title>
    <!-- Use CDN for chess.js and chessboard.js resources -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
</head>
<body>
    <header>
        <h1>SimChess</h1>
        <p>A chess variant where both players move simultaneously</p>
    </header>
    
    <main>
        <div class="game-container">
            <div id="game-status" class="status">
                <h2>Welcome to SimChess!</h2>
                <p>Create a new game or join an existing one to start playing.</p>
            </div>
            
            <div class="controls">
                <button id="create-game">Create New Game</button>
                <div id="join-game-container">
                    <input type="text" id="game-id-input" placeholder="Enter Game ID">
                    <button id="join-game">Join Game</button>
                </div>
            </div>
            
            <div id="game-id-display" class="hidden">
                <p>Game ID: <span id="current-game-id"></span> 
                <button id="copy-game-id">Copy</button></p>
                <p class="help-text">To test: Open another browser window, paste this ID, and join as the second player.</p>
            </div>
            
            <div id="game-board-container" class="hidden">
                <div id="game-board" style="width: 600px"></div>
                
                <div class="game-info">
                    <p>You are playing as: <span id="player-color">-</span></p>
                    <p>Turn: <span id="turn-number">1</span><span id="attempt-number"></span></p>
                    <p id="current-move" class="hidden">Your move: <span id="current-move-text">-</span></p>
                    <p id="waiting-message" class="hidden">Waiting for opponent...</p>
                    
                    <div id="move-controls">
                        <button id="submit-move" class="hidden">Submit Move</button>
                        <button id="reset-move" class="hidden">Reset Move</button>
                    </div>
                    
                    <div id="game-result" class="hidden">
                        <h3>Game Over</h3>
                        <p id="result-message"></p>
                        <button id="new-game">Start New Game</button>
                    </div>
                </div>
                
                <div id="illegal-moves-info" class="hidden">
                    <h3>Illegality & Time</h3>
                    <p>Mutual illegalities: <span id="mutual-illegal">0</span></p>
                    <p>One-sided (white): <span id="white-one-illegal">0</span>/<span id="one-threshold">3</span></p>
                    <p>One-sided (black): <span id="black-one-illegal">0</span>/<span id="one-threshold-2">3</span></p>
                    <p>Clocks â€” White: <span id="white-clock">10:00</span> | Black: <span id="black-clock">10:00</span></p>
                    <p id="illegal-move-reason" class="hidden"></p>
                </div>
                
                <div id="help-section">
                    <h3>How to Play SimChess</h3>
                    <p>1. Drag a piece to make your move</p>
                    <p>2. Click "Submit Move" when ready</p>
                    <p>3. Both players submit moves simultaneously</p>
                    <p>4. Mutual conflicts (e.g., same target square) are mutual illegalities and reset the ply</p>
                    <p>5. One-sided illegalities are counted per player; at 3, a -30s penalty applies and the counter resets</p>
                    <p>6. Standard chess rules apply otherwise</p>
                </div>
            </div>
        </div>
    </main>
    
    <script>
        $(function() {
            let socket;
            let board;
            let game;
            let playerColor;
            let gameId;
            let currentMove = null;
            let localChessGame = new Chess();
            let allowMoves = true;
            let attemptNumber = 0;
            let pendingPosition = null;
            
            // Event handlers
            $('#create-game').click(function() {
                $.post('/api/create_game', function(data) {
                    gameId = data.game_id;
                    initializeSocket();
                    $('#current-game-id').text(gameId);
                    $('#game-id-display').removeClass('hidden');
                    $('#game-status').html(`<h2>Game Created!</h2><p>Waiting for opponent to join...</p>`);
                });
            });
            
            $('#join-game').click(function() {
                gameId = $('#game-id-input').val().trim();
                if (gameId) {
                    initializeSocket();
                } else {
                    alert('Please enter a Game ID');
                }
            });
            
            $('#copy-game-id').click(function() {
                const gameIdText = $('#current-game-id').text();
                navigator.clipboard.writeText(gameIdText).then(function() {
                    $('#copy-game-id').text('Copied!');
                    setTimeout(function() {
                        $('#copy-game-id').text('Copy');
                    }, 2000);
                });
            });
            
            $('#submit-move').click(function() {
                if (currentMove) {
                    socket.emit('submit_move', { 
                        game_id: gameId, 
                        color: playerColor, 
                        move: currentMove 
                    });
                    
                    // Store the pending position so we don't revert immediately
                    pendingPosition = board.position();
                    
                    // Disable controls until next turn
                    $('#submit-move').addClass('hidden');
                    $('#reset-move').addClass('hidden');
                    $('#waiting-message').removeClass('hidden');
                    allowMoves = false;
                } else {
                    alert('Please make a move first');
                }
            });
            
            $('#reset-move').click(function() {
                // Reset the current move
                currentMove = null;
                $('#current-move').addClass('hidden');
                
                // Reset the board position to the server's state
                board.position(localChessGame.fen());
                $('#submit-move').addClass('hidden');
                $('#reset-move').addClass('hidden');
            });
            
            $('#new-game').click(function() {
                location.reload();
            });
            
            function initializeSocket() {
                socket = io();
                
                socket.on('connect', function() {
                    socket.emit('join', { game_id: gameId });
                });
                
                socket.on('joined', function(data) {
                    playerColor = data.color;
                    updateGameState(data.game_state);
                    initializeBoard(data.game_state.fen || 'start');
                    $('#game-board-container').removeClass('hidden');
                    $('#player-color').text(playerColor);
                    $('#game-status').html(`<h2>Game Started</h2><p>You are playing as ${playerColor}</p>`);
                    allowMoves = true;
                });
                
                socket.on('player_joined', function(data) {
                    updateGameState(data.game_state);
                    $('#game-status').html(`<h2>Game Started</h2><p>Opponent joined as ${data.color}</p>`);
                    allowMoves = true;
                });
                
                socket.on('move_submitted', function(data) {
                    updateGameState(data.game_state);
                    
                    if (data.color !== playerColor) {
                        $('#waiting-message').html('Opponent has submitted their move. Waiting for you...');
                        $('#waiting-message').removeClass('hidden');
                        allowMoves = true;
                    }
                });
                
                socket.on('moves_processed', function(data) {
                    const result = data.result;
                    const state = data.game_state;
                    
                    // Only update the game state if both players made valid moves
                    // or we're starting a completely new turn
                    if (result.turn_complete || pendingPosition === null) {
                        updateGameState(data.game_state);
                        
                        // Update the local chess game with the new FEN
                        localChessGame = new Chess(data.game_state.fen);
                        
                        // Update board with new position
                        if (board) {
                            board.position(data.game_state.fen);
                        }
                    } else {
                        // Illegality (mutual or one-sided): both clients revert to last legal state
                        board.position(localChessGame.fen());
                        pendingPosition = null;
                        currentMove = null;
                        
                        // Update UI state from server
                        updateGameState(data.game_state);
                    }
                    
                    // Reset current move
                    currentMove = null;
                    pendingPosition = null;
                    $('#current-move').addClass('hidden');
                    
                    // Check if this was an illegal move attempt
                    const turnNumberDisplay = data.game_state.turn_number;
                    $('#turn-number').text(turnNumberDisplay);
                    
                    // Update attempt number if there are illegal moves
                    attemptNumber = data.game_state.illegal_attempt || 0;
                    if (attemptNumber > 0) {
                        $('#attempt-number').text('.' + attemptNumber);
                    } else {
                        $('#attempt-number').text('');
                    }
                    
                    // Show move results
                    let statusHtml = `<h2>Turn ${turnNumberDisplay}${attemptNumber > 0 ? '.' + attemptNumber : ''}</h2>`;
                    
                    if (result.valid_moves && result.valid_moves[playerColor] === false) {
                        const reason = result.illegal_reason[playerColor];
                        $('#illegal-move-reason').text(`Your move was illegal: ${reason}`);
                        $('#illegal-move-reason').removeClass('hidden');
                        
                        // Enable move controls for the player to try again
                        allowMoves = true;
                        $('#waiting-message').addClass('hidden');
                    } else {
                        $('#illegal-move-reason').addClass('hidden');
                    }

                    // Penalty feedback
                    if (result.penalty_applied) {
                        const penalized = result.penalty_applied.color;
                        const secs = result.penalty_applied.seconds;
                        statusHtml += `<p>Penalty: -${secs}s applied to ${penalized} for repeated one-sided illegality.</p>`;
                    }
                    
                    // Check for game end
                    if (data.game_state.game_over) {
                        if (data.game_state.winner) {
                            const winMessage = data.game_state.winner === playerColor ? 
                                'You won!' : 'You lost!';
                            statusHtml += `<p><strong>${winMessage}</strong> Game ended by checkmate.</p>`;
                            $('#result-message').text(`${data.game_state.winner} wins by checkmate!`);
                        } else if (data.game_state.draw_reason) {
                            statusHtml += `<p><strong>Game drawn</strong> by ${data.game_state.draw_reason}.</p>`;
                            $('#result-message').text(`Draw by ${data.game_state.draw_reason}`);
                        }
                        
                        $('#game-result').removeClass('hidden');
                        $('#waiting-message').addClass('hidden');
                    } else {
                        // Reset for next turn
                        allowMoves = true;
                        $('#waiting-message').addClass('hidden');
                    }
                    
                    $('#game-status').html(statusHtml);
                    
                    // Update new illegality counters and clocks
                    $('#mutual-illegal').text(state.mutual_illegal_count || 0);
                    if (state.one_sided_illegal_counts) {
                        $('#white-one-illegal').text(state.one_sided_illegal_counts.white || 0);
                        $('#black-one-illegal').text(state.one_sided_illegal_counts.black || 0);
                    }
                    const threshold = state.one_sided_threshold || 3;
                    $('#one-threshold').text(threshold);
                    $('#one-threshold-2').text(threshold);
                    if (state.clock_seconds) {
                        $('#white-clock').text(formatSeconds(state.clock_seconds.white));
                        $('#black-clock').text(formatSeconds(state.clock_seconds.black));
                    }
                    if ((state.mutual_illegal_count || 0) > 0 ||
                        (state.one_sided_illegal_counts && (state.one_sided_illegal_counts.white > 0 || state.one_sided_illegal_counts.black > 0))) {
                        $('#illegal-moves-info').removeClass('hidden');
                    }
                });
                
                socket.on('error', function(data) {
                    alert('Error: ' + data.message);
                });
            }
            
            function initializeBoard(initialPosition) {
                // Initialize the chess game object
                localChessGame = new Chess(initialPosition);
                
                function onDragStart(source, piece) {
                    // Allow dragging only when moves are allowed
                    if (!allowMoves) return false;
                    
                    // Only allow players to move their own pieces
                    if ((playerColor === 'white' && piece.search(/^b/) !== -1) || 
                        (playerColor === 'black' && piece.search(/^w/) !== -1)) {
                        return false;
                    }
                    
                    return true; // Allow the drag
                }
                
                function onDrop(source, target) {
                    // Accept the intention without strict legality checks (simultaneous rules)
                    // Build UCI string
                    currentMove = source + target;
                    
                    // Add promotion only if the moving piece is a pawn reaching last rank
                    const pieceAtSource = localChessGame.get(source);
                    if (pieceAtSource && pieceAtSource.type === 'p') {
                        const rank = target.charAt(1);
                        const isWhite = pieceAtSource.color === 'w';
                        const isPromotionRank = (isWhite && rank === '8') || (!isWhite && rank === '1');
                        if (isPromotionRank) {
                            currentMove += 'q';
                        }
                    }
                    
                    // Show the move in the UI
                    $('#current-move-text').text(`${source} to ${target}`);
                    $('#current-move').removeClass('hidden');
                    
                    // Show submission controls
                    $('#submit-move').removeClass('hidden');
                    $('#reset-move').removeClass('hidden');
                    
                    // Don't snap back - leave the piece where it was dropped
                    return true;
                }
                
                // Configuration for the chessboard
                const config = {
                    position: initialPosition,
                    orientation: playerColor === 'white' ? 'white' : 'black',
                    showNotation: true,
                    pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
                    draggable: true,
                    onDragStart: onDragStart,
                    onDrop: onDrop
                };
                
                // Initialize the board
                board = Chessboard('game-board', config);
                
                // Make the board responsive
                $(window).resize(function() {
                    board.resize();
                });
            }
            
            function updateGameState(gameState, preservePosition = false) {
                $('#turn-number').text(gameState.turn_number);
                
                // Update attempt number if there are illegal moves
                attemptNumber = gameState.illegal_attempt || 0;
                if (attemptNumber > 0) {
                    $('#attempt-number').text('.' + attemptNumber);
                } else {
                    $('#attempt-number').text('');
                }
                
                // Update the board position only if we receive a new FEN state
                // and we're not preserving the current position for visual feedback
                if (gameState.fen && board && !preservePosition && !pendingPosition) {
                    // Update the local chess game with the server's FEN
                    localChessGame = new Chess(gameState.fen);
                    // Update the board to the server's state
                    board.position(gameState.fen);
                    // Clear the current move since we've updated to the server state
                    currentMove = null;
                    $('#current-move').addClass('hidden');
                }
                
                // Handle UI state based on move submission status
                if (gameState.white_ready && gameState.black_ready) {
                    // Both players have moved, hide waiting message
                    $('#waiting-message').addClass('hidden');
                } else if ((playerColor === 'white' && gameState.white_ready) || 
                        (playerColor === 'black' && gameState.black_ready)) {
                    // This player has submitted their move, waiting for opponent
                    $('#waiting-message').text('Waiting for opponent to submit move...');
                    $('#waiting-message').removeClass('hidden');
                    $('#submit-move').addClass('hidden');
                    $('#reset-move').addClass('hidden');
                } else {
                    // This player needs to submit a move
                    $('#waiting-message').addClass('hidden');
                    
                    // Only show submit/reset buttons if the player has made a move
                    if (currentMove) {
                        $('#submit-move').removeClass('hidden');
                        $('#reset-move').removeClass('hidden');
                    } else {
                        $('#submit-move').addClass('hidden');
                        $('#reset-move').addClass('hidden');
                    }
                }
            }

            function formatSeconds(totalSeconds) {
                const s = Math.max(0, parseInt(totalSeconds || 0, 10));
                const m = Math.floor(s / 60);
                const sec = s % 60;
                return `${m}:${sec.toString().padStart(2, '0')}`;
            }
        });
    </script>
</body>
</html>
